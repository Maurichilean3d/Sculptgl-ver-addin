import MeshStatic from 'mesh/meshStatic/MeshStatic';

var Import = {};

Import.importGLB = function (buffer, gl) {
  var data = new DataView(buffer);
  var magic = data.getUint32(0, true);
  
  // Validar Magic 'glTF'
  if (magic !== 0x46546C67) {
    console.error('Formato inválido, no es un GLB');
    return [];
  }
  
  var version = data.getUint32(4, true);
  if (version !== 2) {
    console.error('Solo se soporta glTF 2.0');
    return [];
  }

  var length = data.getUint32(8, true);
  var jsonChunkLength = data.getUint32(12, true);
  var jsonChunkType = data.getUint32(16, true);
  
  // Leer JSON
  var jsonText = new TextDecoder().decode(new Uint8Array(buffer, 20, jsonChunkLength));
  var json = JSON.parse(jsonText);
  
  // Localizar el BIN Chunk
  var binChunkStart = 20 + jsonChunkLength;
  var binChunkLength = 0;
  if (binChunkStart < length) {
      binChunkLength = data.getUint32(binChunkStart, true);
      // var binChunkType = data.getUint32(binChunkStart + 4, true);
  }
  
  // Acceso al binario global
  var binBuffer = new Uint8Array(buffer, binChunkStart + 8, binChunkLength);

  var meshes = [];
  
  var getBuffer = function(accessorIndex) {
      var accessor = json.accessors[accessorIndex];
      var bufferView = json.bufferViews[accessor.bufferView];
      var byteOffset = (bufferView.byteOffset || 0) + (accessor.byteOffset || 0);
      
      // Asumimos que todos los buffers apuntan al buffer 0 (el BIN chunk interno)
      // glTF permite URIs externos pero en GLB suele ser todo interno.
      
      var arrayType;
      // Component Type
      if(accessor.componentType === 5126) arrayType = Float32Array;
      else if(accessor.componentType === 5125) arrayType = Uint32Array;
      else if(accessor.componentType === 5123) arrayType = Uint16Array;
      else if(accessor.componentType === 5121) arrayType = Uint8Array;
      
      // Crear vista tipada sobre el slice del buffer binario
      var slice = binBuffer.buffer.slice(
          binBuffer.byteOffset + byteOffset, 
          binBuffer.byteOffset + byteOffset + bufferView.byteLength
      );
      return new arrayType(slice);
  };

  // Recorrer Nodos -> Mallas
  var nodes = json.scenes ? json.scenes[json.scene || 0].nodes : [];
  
  // Función recursiva o lineal para encontrar mallas
  // Para simplificar, buscamos en todos los nodos que tengan 'mesh'
  var processNode = function(nodeIdx) {
      var node = json.nodes[nodeIdx];
      if (node.mesh !== undefined) {
          var meshDef = json.meshes[node.mesh];
          
          for (var i = 0; i < meshDef.primitives.length; i++) {
              var prim = meshDef.primitives[i];
              var newMesh = new MeshStatic(gl);
              
              // Vértices
              if (prim.attributes.POSITION !== undefined) {
                  var posArr = getBuffer(prim.attributes.POSITION);
                  newMesh.setVertices(posArr);
              }
              
              // Índices (Caras)
              if (prim.indices !== undefined) {
                  var indArr = getBuffer(prim.indices);
                  // SculptGL necesita Uint32 para las caras
                  newMesh.setFaces(new Uint32Array(indArr)); 
              }
              
              // Colores
              if (prim.attributes.COLOR_0 !== undefined) {
                  var colArr = getBuffer(prim.attributes.COLOR_0);
                  newMesh.setColors(colArr);
              } else {
                  // Si no hay color, inicializar en blanco
                  var nb = newMesh.getNbVertices();
                  var colors = new Float32Array(nb * 3);
                  colors.fill(1.0); // Rellenar blanco
                  newMesh.setColors(colors);
              }

              // Materiales (por ahora default)
              var nbV = newMesh.getNbVertices();
              var materials = new Float32Array(nbV * 3);
              // PBR default rough/metal
              for(var k=0; k<materials.length; k+=3) {
                  materials[k] = 0.1; // roughness
                  materials[k+1] = 0.5; // metalness
                  materials[k+2] = 1.0; // mask
              }
              newMesh.setMaterials(materials);

              meshes.push(newMesh);
          }
      }
      if (node.children) {
          node.children.forEach(processNode);
      }
  };

  if (nodes) nodes.forEach(processNode);

  return meshes;
};

export default Import;
